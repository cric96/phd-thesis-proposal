\documentclass[11pt]{article}
\usepackage{mgates-letter}
\definecolor{dark_blue} {rgb}{0., 0., 0.65}
\usepackage{makecell}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{mathrsfs}  % mathscr font
\usepackage{boxedminipage}
\usepackage{rotating}
\usepackage{csquotes}
%\usepackage{natbib}
\usepackage[colorlinks, filecolor=dark_blue, urlcolor=dark_blue, linkcolor=black, citecolor=black]{hyperref}

\begin{document}
\sloppy
\begin{center}
	{{
		\Large{
			\textsc{PhD Programme in Computer Science and Engineering \\ 
			\vspace{4mm}
			Cycle XXXVI}
			}
	}} 
	\rule[0.1cm]{\textwidth}{0.1mm}
	\rule[0.4cm]{\textwidth}{0.6mm}
\end{center}

\begin{center}
	{\LARGE{Engineering Cyber-Physical Swarms with Aggregate Computing}} \\
	\vspace{4mm}
	{\large{PhD Thesis proposal}} 
	\vspace{4mm}
\end{center}
\vspace{8mm}
\par
\noindent
\begin{minipage}[t]{0.47\textwidth}

{\large{Commission: \\\bf
Prof. Mirko Viroli \\
Prof. Andrea Omicini \\
Prof. Matteo Ferrara} 
}
\end{minipage}
\hfill
\begin{minipage}[t]{0.47\textwidth}
	\raggedleft
	{
		\large{PhD Student: \\\bf Gianluca Aguzzi}
	}
\end{minipage}
\vspace{10mm}

{
	\raggedright
	\rule[0.1cm]{\textwidth}{0.6mm}
	\rule[0.5cm]{\textwidth}{0.1mm}
}

\newcommand{\scafiweb}{{ScaFi-Web}}
\newcommand{\acfull}{{aggregate computing}}
\newcommand{\ac}{{AC}}
\newcommand{\scafi}{{ScaFi}}
\newcommand{\cpsw}{{CPSw}}
\newcommand{\rev}[1]{{
	%\color{red}
	#1
	}}
\abstract{
	This thesis aims to define a path towards the engineering of ``Cypher-Physical Swarms" (\cpsw{}) - where swarms are seen in a modern key, including swarm robotics, large-scale IoT scenarios, and crowd engineering (tracking and control). 
	%
	\cpsw{} are backed by emerging trends of autonomic, pervasive, ubiquitous computing that foster a vision of distributed systems composed of a considerable number of simple entities that collectively perform collective tasks.
	%
	These systems are similar to natural social-animal groups, where plentiful animals (like ants, sheep, ...) achieve complex tasks (foraging, flocking, ...).
	%
	Furthermore, these behaviour are typically achieved through self-organisation, making the system robust to failures and highly scalable.
	%
	Inspired by nature, we led to defining the notion of ``Cypher-Physical Swarm'' -- the extension of `swarms' in computer science.
	%
	Engineering this kind of system with traditional approaches is inadequate, 
	due to the distributed control, high-rate failure, openness, and local-to-global behaviour mapping.
	%
	Therefore, my thesis is focused on finding a systematic and reproducible way to design \cpsw{}. 
	In particular, we plan to leverage \acfull{} -- a novel top-down global-to-local programming model.
	%
	As a final result of my PhD, we intend to analyse the application of \acfull{} in \cpsw{}. This will touch on several aspects like distributed intelligence, flexible and opportunistic middlewares, building blocks and ad-hoc API.
}
\newpage
\tableofcontents
\section{Introduction}
The recent evolution of IT technologies led to a vision in which computation is \textit{everywhere}. Several modern paradigms advance that vision, like ubiquitous~\cite{DBLP:journals/sigmobile/Weiser99}, pervasive~\cite{DBLP:journals/computer/SahaM03}, collective~\cite{DBLP:journals/computer/Abowd16}, and automatic computing~\cite{DBLP:journals/computer/KephartC03}.
%
These consider systems (typically cypher physical) where a large number (thousand - million) of simple interacting devices collectively perform complicated tasks in a decentralised manner, acting and sensing through a shared environment. 
%
Thus, they can be conceived as \textit{complex} systems like the one observed in nature --  by means that we cannot understand the behaviour of the whole looking only at the parts.
%
Speaking about \textit{natural} complex systems, social animals, like a swarm of insects, exhibit fault-tolerant, effective, and efficient collective behaviours leveraging self-organisation.

Consequently, we want to promote cypher-physical systems with the properties observed in swarms. 
%
Therefore we lead to define \textit{Cypher-Physical-Swarm} (\cpsw{}): a collection of (simple) computational entities linked with the physical world via perception and actuation that reach collective goals through self-organising behaviours.
%
Swarm robotics, ``swarms” of people (crowds) or, in general, ``swarms” of IoT devices are clearly defined instances of \cpsw{}.

Traditional design methodologies are inadequate for \cpsw{} engineering, due to local-to-global mapping problems, distributed control, complex IT infrastructures and scalability concerns.
%
Following this line, the goal of my research PhD thesis is to find a systematic methodology (models, techniques and algorithms) to synthesise and deploy self-organising behaviours with predictable outcomes for \cpsw{}.

This is not the first effort in this direction. Indeed, traditionally, designers have been guided
by natural phenomena observation that was then transposed into computer systems -- a so-called
bottom-up approach. However, this trend led to specific solutions that hardly scale up with application complexity.
%
Novel techniques -- and the one that we follow in this work -- consist of a top-down global-to-local approach where designers define the system outcome directly at the collective level.
%
Among the many (like Buzz~\cite{DBLP:journals/software/PinciroliB16}, TOTA~\cite{DBLP:conf/icdcsw/MameiZL03}) in this thesis we will take into consideration \textit{\acfull{}} (\ac{})~\cite{DBLP:journals/computer/BealPV15} since it enables the definition of self-organising collective behaviours that can be composed in a functional manner. In this way, the \textit{aggregate} programs (i.e. programs written using \ac{}) can be reused in different scenario and scaled with complexity. 

Even if \ac{} is applied already in different scenarios like crowds of people~\cite{DBLP:journals/computer/BealPV15}, smart cities~\cite{DBLP:journals/isci/CasadeiFPRSV19}, and large-scale IoT~\cite{DBLP:journals/fgcs/CasadeiFPRSV19}, it currently lacks software architecture (middleware), systematic program definition, abstraction layers (API) and foundational aspects.
%
Consequently, my thesis aims to investigate and analyse critically Aggregate
Computing techniques in the field of \cpsw{}. 
%
This investigation will address multiple directions like distributed intelligence, flexible middlewares, and ad-hoc building blocks, possibly leading to contributions both at a foundational (i.e. building blocks, \ac{} language, API) and ``architectural" level (middleware, message passing architecture, ...).
%
In this process, Machine Learning (ML) -- and in particular Reinforcement Learning (RL) -- techniques will be used in support of \acfull{}~\cite{research} to improve adaptivity, efficiency and efficacy

The proposal is then structured as follow. In \Cref{background} I discuss the current state-of-the-art methodologies and related works in the field \cpsw{} behaviour definition.
%
In \Cref{contribution} I devise my thesis contribution in the path of engineering predictable outcome in \cpsw{}. Furthermore, I show my preliminary works done in my first PhD year
%
Finally, in \Cref{future} I describe what are the activities that I plan to do in the rest of my PhD project.

\section{Background} \label{background}
The goal of this section is to clarify what we mean with \textit{Cypher-Physical Swarm}, what systems are similar to our definition and what research area have to deal with similar problematics.
\subsection{Cypher-Physical Swarms}
This term is a novel way to see a large number of computational nodes that collaborate to solve a collective problem as the behaviour that we observed in natural ``swarm'' systems.
%
These systems have a large population of networked nodes (hundreds -- thousands), and then are typically \textit{open} (i.e. we cannot know the total node number apriori). This means that the collective behaviour that we will define should be \textit{scale independent} (i.e. the same program have to work in small networks as well as in very large networks).
%
Nodes then are associated with a \textit{physical} asset through sensors and could change the environment using actuators. Namely, they are embodied in the world -- so the name of cypher-physical. 

%We tend to not use \textit{agent} because the computational part could be not autonomous but only reactive (so weak agent notion could be used).

The nodes could be heterogenous but we imagine a homogenous node behaviour (i.e. each node should be able to execute the same local logic). Furthermore, nodes act collaboratively, and are not selfish -- they operate always for the global collective utility.

We presuppose that the overall system could not use a central entity -- so we need to deal with distributed control. Even if modern architectures could be used (e.g cloud/edge infrastructures) in general we need to fastly react to local problems and so moving this decision far from the physical assets could be dangerous (because are kind of \emph{critical systems}).
As a concluding note, we are interested in the \textit{macro-level} behaviour, and not at the \textit{micro-level}. Hence we intend to describe the collective not by emergence, but by defining a global wanted structure.

To make a comparison of other similar definitions, \cpsw{} is a kind of Complex Adaptive system~\cite{holland1992complex}, but our vision enforces properties that and not necessarily in standard complex systems definition like the large agents' number and the collaborative agents' nature.
%%
Collective Adaptive Systems~\cite{DBLP:journals/corr/abs-1108-5643} is near to our \cpsw{} description but in our definition agents pursuit \emph{collective} (non individual) goal and the node have an \emph{homogenous} behaviour.
\subsection{Swarm Intellingece}
Swarm intelligence has a similar starting point as our approach since it tries to use the tactics observed in ants -- social animals in general -- in swarm robotics. The approach here is bottom-up, so designers had tried to achieve a collective behaviour through emergence observing local animal behaviours.
%
For instance, artificial stigmergy~\cite{DBLP:journals/fgcs/DorigoBT00} derives from that studies. But, for swarm intelligence branch is more focused on algorithms. 
Indeed, the collective behaviour observed in nature are leveraged to perform \textit{optimization} strategy -- or to solve directly some problem by searching in the solution space.
%%
There are several examples in this direction, such as Ant Colony Optimization (ACO)~\cite{DBLP:journals/tsmc/DorigoMC96}, Particle Swarm Optimization (PSO)~\cite{DBLP:conf/icnn/KennedyE95} and Flock of Starling Optimization (FSO)~\cite{DBLP:series/sci/FulgineiS11}.

Even if are important approaches, we are not directly interested in them. Indeed we take \textit{inspiration} from swarms but only to achieve similar behaviour in the artificial swarm leveraging self-organisation. We do not want to \textit{mimic} nature but leverage the same mechanism to reach robust collective systems.
\subsection{Swarm Robotics}
Historically, swarm robotics started from the first Swarm intelligence approaches. Then, it is defined as the \textit{engineering} part of that branch. Indeed, the general goal of this branch is \emph{to define systematic and well-founded procedures for modelling, designing, realising, verifying, validating, operating, and maintaining a swarm robotics system}~\cite{DBLP:journals/swarm/BrambillaFBD13}.

Here the focused are mainly or \textit{robots} that are \emph{autonomous}, \emph{situated}, and with \emph{no central control}. We aim to expand this vision also to other ``swarm-like'' systems, as a crowd of people, large scale IoT and smart cities where we do not have robots. 

In particular, the novel branch of \textit{automatic design}~\cite{DBLP:journals/firai/FrancescaB16} is very appealing to be used in a wider sense -- namely in \cpsw{}. Here the controller is derived through \textit{genetic algorithms} or \textit{Multi-agent Reinforcement Learning} following a \textit{global} utility function. 
\subsection{Multi-Agent Systems}
A \cpsw{} could be seen as a multi-agent system and in particular a \emph{many}-agent system where a group of autonomous entities are programmed to achieve some collective behaviour through \emph{repeated} sensing, computation, communication, and actuation.

Due to the high stochasticity of the environment, it is almost impossible to know and program the optimal behaviour for all agents in advance.

This uncertainty results in the need of creating intelligent agents so that they can \emph{learn} the optimal behaviour and adapt to environmental changes.
\subsubsection{Learning}
In recent decades there has been an emerging trend in the use of RL 
in multi-agent settings -- called Multi-Agent Reinforcement Learning (MARL) -- as a powerful, robust and adaptive learning paradigm.
%
Progress has been considerable and a wide range of algorithms are now available.

MARL is a conjunction of Game theory and RL, 
 and there are several (even orthogonal) viewpoints on which researchers have been focused.
First attempts from RL viewpoint, 
 goes towards a so-called \textit{independent learning}~\cite{DBLP:journals/tsmc/BusoniuBS08} approach, where each agent learn locally against the whole environment~\cite{DBLP:conf/icml/Tan93}.

%%% Put reference to independent learning overview
The pro of these approaches is that their complexity does not scale up with the number of agents, 
 but, unfortunately, the learning process is extremely non-stationary and unstable.
% 
Furthermore, they are heuristic and do not exist any convergence proof (even if, in practice, they often reach a good policy).

Other efforts have focussed on achieving equilibria such as Nash-equilibrium of Pareto optimality.
The problem is that it is used with few agents and scale hardly with the application complexity.
%
Finally, current emerging trends tend to leverage a so-called centralised training and decentralised execution (CTDE) approach, by which 
 agents should leverage the system-wide knowledge at training time but at runtime, they act independently~\cite{DBLP:journals/aamas/Hernandez-LealK19}. In this direction, Deep learning is typically employed reaching and exceeding the state-of-the-art traditional MARL algorithms.
 
The main problem with most of the solutions available in the literature is that they consider a  small number -- even if some novel trends exist, like Mean Field Reinforcement Learning of agents (or at least test them on small games).
Furthermore in \cpsw{} we are mainly interested in learning algorithms that tackle \emph{homogenous} behaviour, i.e. the policy founded could be shared with the entire collective.
\subsection{Aggregate Computing}

\ac{} is an approach to specify or \emph{self-organising} behaviour of a MAS from a global perspective.
%
The aggregate program (i.e. a program written with \ac{}) provides a way to map the local observations of an individual agent (i.e., sensing information, current agent state, and inbound messages from neighbours) to (eventually) globally-coherent local actions
 (i.e., actuation instructions, and outbound messages).
%

Historically, aggregate programming originated from works drawing inspiration from nature: whereas the biological inspiration led to swarm intelligent MASs, where agent indirectly interact by pheromones \cite{DBLP:conf/atal/ParunakBS02}, the physical inspiration led to the idea of agents acting in environments empowered with potential fields \cite{DBLP:journals/trob/HwangA92}.
%
Recently, aggregate programming has been formally backed by \emph{field calculi}~\cite{viroli2019jlamp-si-coord}, which provide a compositional approach
 to global behaviour specification
 based on functions from fields to fields.
%
A \emph{(computational) field} is a map associating a value to any device of a given domain.
%
So, for instance, controlling the movement of a swarm of drones can be expressed through a field of velocity vectors, which maps any drone of the swarm to a corresponding velocity (speed and direction); the set of low-energy devices can be denoted through a Boolean field holding \texttt{true} for devices whose local energy level (as perceived by local sensors, and collectively also denoted as a floating-point field) is under a certain threshold (also a floating-point field).
%
These fields, then, are generally manipulated through three kinds of constructs:
\begin{enumerate}
\item \emph{Stateful evolution}: \lstinline|rep(init)(f)|---expressing how a field, starting as \lstinline|init|, should evolve round-by-round through unary function \lstinline|f|.
\item \emph{Neighbour interaction}: \lstinline|nbr(e)|---used to exchange with neighbours the value obtained by evaluating field expression \lstinline|e|; this locally yields a \emph{neighbouring field}, i.e., a field that maps any neighbour to the corresponding evaluation of \lstinline|e|.
\item \emph{Domain partitioning}: \lstinline|branch(c){ifTrue}{ifFalse}|---used to partition the domain of devices into two parts: the devices for which field \lstinline|c| is locally \lstinline|true|, which evaluate expression \lstinline|ifTrue|, and those for which \lstinline|c| yields \lstinline|false|, which evaluate \lstinline|ifFalse|. 
\end{enumerate}
%
The idea of aggregate programming is to 
 write programs talking about global behaviour (fields)
 and let these drive the local activity of every device in the system.
%
Aggregate programming is embodied by concrete aggregate programming languages~\cite{viroli2019jlamp-si-coord},
 such as \scafi{}~\cite{DBLP:conf/isola/CasadeiVAD20,DBLP:journals/eaai/CasadeiVAPD21},
 a Domain-Specific Language (DSL) embedded in Scala
 as well as a toolchain for aggregate system development and simulation~\cite{Casadei2016mass}.
%

As target toolkit, we will adopt \scafi{} in this my thesis work mostly for practical reasons: with respect to other aggregate programming languages such as Proto and Protelis, surveyed in \cite{viroli2019jlamp-si-coord},
\scafi{} is a \emph{strongly typed}, \emph{internal} DSL; therefore, it enables straightforward reuse of powerful features from the Scala host language (including its type system, type inference, programming abstractions, libraries).

Additionally, ScaFi also represents an agile framework for testing experimental language features (cf. \emph{aggregate processes}~\cite{DBLP:journals/eaai/CasadeiVAPD21}.
%
Hence, among the existing languages for aggregate programming, we believe \scafi{} is the one better fitting rich scenarios like what we expected for \cpsw{}.

A full account of research about aggregate programming, field calculi, and \scafi{} is beyond the scope of this proposal; more details can be found in~\cite{viroli2019jlamp-si-coord,DBLP:journals/eaai/CasadeiVAPD21}.

\section{Contribution} \label{contribution}
\subsection{Thesis proposal}
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{img/to-do-for-thesis.pdf}
	\caption{Devise the current status of \ac{} toolkit in literature. Dotted blocks mean a lack of that concept. Green block are the one that can be consider stable and reusable in \cpsw{} engineering. Red Block are the one that currently exists but need to be expanded in order to support \cpsw{}.}
	\label{fig:current-state}
\end{figure}
My PhD thesis will be focused on the engineering process of \cpsw{} leveraging \ac{} abstractions. The choice of \ac{} as a conceptual model for describing \cpsw{} behaviours is well fitted since it:
\begin{itemize}
	\item allows defining collective behaviour failure robust and scale-independent: the aggregate programs are expressed through manipulation of computational field, abstracting over nodes itself and treating the systems like a computational blob that evolves in time. In doing that, the logic is independent of the node population, so it handles natively failure, openness and the same program can be applied to very dense IT networks.
	\item enhances the possibility to \textit{program} self-organisation: Typically, self-organisation is something that was achieved by observing natural phenomena. \ac{} wants to give a systematic way to let \textit{self-organising} behaviour programmable. To do that, the programs are defined using a composition of building blocks that expose self-organising patterns.
	\item is applicable to different deployment kinds leveraging modern complex IT infrastructures: Aggregate program does not depend on any particular IT network framework. Potentially, it could be applied in cloud-like systems, P2P networks and client and server architecture (the direction of pulverisation). This is particularly important for \cpsw{} since they could leverage different kinds of networks.
\end{itemize}

This choice impact strongly on the design process of collective application. Some of the concerns are already tackled in related words but others are currently quite unexplored and for us are essential in the context of \cpsw{}, and this is where my thesis work will be focused on.
In particular, the main concerns where my work is placed are:
\begin{itemize}
	\item development of \textit{flexible} middleware: In this year, the main effort of this line of the research concern \textit{foundational} aspects. However, currently, little effort is done to make aggregate programs applicable to various deployment kinds. Furthermore, we would like to leverage current IT infrastructures opportunistically (like edge computing or osmotic computing). In this line, in my thesis, I would produce software artefact in order to \textit{support} such kind of middleware for \cpsw{}.
	\item building blocks definition from \cpsw{}: During the study and the analysis of cpswWs, we would encounter the possibility of describing new building blocks. For instance, in swarms the concept of \emph{cluster} is central for several reasons: identifying a group of entities with common capabilities, we can use it to produce a mean view of a certain zone, and so on. Therefore, we probably need to enlarge the current building block set to new constructs, that possibly could be useful also to other scenarios (like smart cities, smart grid, ...).
	\item definition of API for swarm-like behaviour: \ac{} is based on a layered approach. Typically, for each different scenario, developers should define an API to support a particular kind of application. So, in this thesis, we will focus on the definition of common abstraction needed to program \cpsw{}. Here novel abstraction used in reactive programming and functional programming could be an effective way to express \textit{swarm} behaviour enhancing compositionality.
	\item improvements of the entire \ac{} stack with Machine Learning: \ac{} stack concern different aspects, from API to field-calculus to middleware. Machine Learning -- and in particular Reinforcement Learning -- in this context could be used as an intrinsic mechanism to improve adaptivity. In general, we do not want to use Machine Learning to completely synthesise a program (as done in automatic design). Here we want to reach a kind of \textit{hybrid} approach, we a part of the system learns through experience but another is yet defined declaratively using \ac{} abstractions
\end{itemize}

\subsection{Preliminary contributions}
In my first year of PhD, my activities have been centred on
the integration of \ac{} with Machine Learning capability to create even more
intelligent collective behaviour. 

My work climaxes with ~\cite{research} where I explain different suitable approaches to
enhance \ac{} with Machine learning. Finally, in the last period, I made concrete
experiments with Reinforcement Learning -- in particular, Hysteretic Q-Learning \cite{hysteretic-q} -- improving the current \ac{} solutions.

Concerning middleware aspects, my research activities aim at closing the gap between
its abstract space and its application in concrete systems. In this direction, I made mainly contributions to \scafi. In particular, we produce two articles concerning ScaFi-Web -- a web-based tool that could support monitoring aspects and \scafi Loci -- a type-safe deployment methodology leveraging multi-tier programming.
\subsubsection{ScaFi-Web -- A tool for a distributed monitoring}
\scafiweb{}\footnote{\url{https://scafi.github.io/web}}
 is an online playground for learning \ac{}, experimenting with it, and monitoring executions in a browser.
% a  web-based platform supporting \scafi{} in-browser that
It currently features:
\begin{itemize}
 \item an interactive editor for writing \scafi{} programs;
 \item a guided tour of the most prominent features, kickstarting development;
 \item an in-browser simulated network of devices hosting the execution;
 \item visualisation, inspection, and interaction tools integrated with the simulated environment.
\end{itemize}

Furthermore, it also provides a stepping stone towards a monitoring and control system for \ac{} deployments.

Indeed, In the context of field-based coordination, automated runtime verification approaches have been recently investigated, whereby spatial or temporal logics are mapped to field calculus programs to directly encode the behaviour of decentralised monitoring.

The \scafiweb{}'s frontend has been designed to be adaptable to different backends; indeed, the UI is completely separated from the underlying aggregate execution system. 

\subsubsection{ScaFi Loci -- Towards a type-safe deployment of Pulverised Architecture}
\ac{} defines a conceptual model by which is possible to define collective computation. Practically, each node needs to have a notion of the neighbourhood (i.e what nodes are near to me) following a certain metric. \textit{How} this neighbourhood is built, is transparent for the computational model. Therefore it is possible to deploy the same application in different IT networks.

Pulverised architectures (i.e. pulverisation) go in this direction, identifying the main \textit{deployable} units that can be moved in different concrete nodes, the core idea is that the functional
the behaviour of a distributed application is fundamentally orthogonal to the actual deployment of the services that compose it.

However, pulverisation does not specify how a pulverised architecture should
be described and verified so that it can be operated correctly
at runtime.
Therefore, in \scafiweb Loci we define an architecture for multitiered deployment strategies in pulverised systems, along with an implementation using ScaFi and ScalaLoci.

The latter enables a \textit{typesafe} multitier programming approach -- by which distributed architecture is defined
in a single compilation unit with a single language.

This work could be seen as a piece of the flexible middleware that we intend to build, focused only on the deployment aspects.

\section{Future works}\label{future}
This section concludes the thesis proposal defining the next step in the PhD path. In particular, we want to put the first blocks for effective Reinforcement Learning and \acfull{} integrations. Furthermore, we want to define a reusable API applied in \cpsw{} and a first PoF of a flexible middleware combing the first works done in my PhD. 
\subsection{Swarm API}
The thesis will extend the current \ac{} stack with high-level API about swarms behaviours (Swarm API) like flocking, foraging, blinking and spreading of information.  Consequently, self-adaptive properties have to be verified as done in other building blocks.  The swarm API will not only mimic some nature-inspired behaviours, but it will give a general interface to solve common collective problems. The API could be reused under the general collective adaptive system (CAS) context.
\subsection{Improve to speed up convergence: Reinforcement Learning applied to Building Blocks}
\ac{} based its logic in \textit{compositionality} inspired by functional programming. The idea is that complex behaviours can be defined only through the composition of \emph{building blocks}. Furthermore, based on these programming bricks, relevant collective properties are proven such as self-stabilization and eventual consistency. 

Currently, the key problem with those building blocks is that they aren't able to be used in any kind of network topology. Indeed we are dealing with high node dynamic, the overall computation field became quite a noise and unstable -- leading to ever reaching our intended result.

Traditionally these problems are tackled with heuristic/algorithmically to solve various problems (stability of results, convergence speed up, ...). But this led to complex fine-tuning and algorithm choice for each new environment.

Our idea hypothesis in~\cite{research} consists of applied Machine Learning algorithms -- and in particular Reinforcement Learning -- to improve building blocks by means of speeding up the self-stabilisation process.
\subsection{Middleware-level learning}
%% Talk about the aspect of time fuild (distributed scheduler) and space fluid (discard message opportunistically).

\bibliographystyle{ieeetr}
\bibliography{biblio}

\end{document}